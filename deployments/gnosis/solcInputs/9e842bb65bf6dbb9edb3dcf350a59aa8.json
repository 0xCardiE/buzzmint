{
  "language": "Solidity",
  "sources": {
    "contracts/StampsRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/*\n    ███████╗████████╗ █████╗ ███╗   ███╗██████╗ ███████╗\n    ██╔════╝╚══██╔══╝██╔══██╗████╗ ████║██╔══██╗██╔════╝\n    ███████╗   ██║   ███████║██╔████╔██║██████╔╝███████╗\n    ╚════██║   ██║   ██╔══██║██║╚██╔╝██║██╔═══╝ ╚════██║\n    ███████║   ██║   ██║  ██║██║ ╚═╝ ██║██║     ███████║\n    ╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝╚═╝     ╚══════╝\n                                              \n    ██████╗ ███████╗ ██████╗ ██╗███████╗████████╗██████╗ ██╗   ██╗\n    ██╔══██╗██╔════╝██╔════╝ ██║██╔════╝╚══██╔══╝██╔══██╗╚██╗ ██╔╝\n    ██████╔╝█████╗  ██║  ███╗██║███████╗   ██║   ██████╔╝ ╚████╔╝ \n    ██╔══██╗██╔══╝  ██║   ██║██║╚════██║   ██║   ██╔══██╗  ╚██╔╝  \n    ██║  ██║███████╗╚██████╔╝██║███████║   ██║   ██║  ██║   ██║   \n    ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝   ╚═╝   \n*/\n\n/**\n * @title StampsRegistry\n * @notice A registry for Swarm Postage Stamps\n * @dev Note on naming convention: The terms \"Batch\" and \"Stamps\" are used interchangeably throughout the codebase.\n *      \"Batch\" refers to a collection of stamps created in a single transaction and is the terminology used in the\n *      Swarm protocol. \"Stamps\" is a more user-friendly term used to describe the same concept.\n *      For example: \"BatchCreated\" event, but \"StampsRegistry\" contract.\n */\n\ninterface ISwarmContract {\n    function createBatch(\n        address _owner,\n        uint256 _initialBalancePerChunk,\n        uint8 _depth,\n        uint8 _bucketDepth,\n        bytes32 _nonce,\n        bool _immutable\n    ) external;\n\n    function currentTotalOutPayment() external view returns (uint256);\n}\n\ninterface IERC20 {\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\ncontract StampsRegistry {\n    // State variables\n    ISwarmContract public swarmStampContract;\n    IERC20 public constant BZZ_TOKEN =\n        IERC20(0xdBF3Ea6F5beE45c02255B2c26a16F300502F68da);\n    mapping(bytes32 => address) public batchPayers;\n    address public admin;\n    \n    // New data structure to store batch information by owner\n    struct BatchInfo {\n        bytes32 batchId;\n        uint256 totalAmount;\n        uint256 normalisedBalance;\n        address nodeAddress;\n        address payer;\n        uint8 depth;\n        uint8 bucketDepth;\n        bool immutable_;\n        uint256 timestamp;\n    }\n    \n    // Mapping from owner address to array of BatchInfo\n    mapping(address => BatchInfo[]) public ownerBatches;\n    \n    // Events\n    event BatchCreated(\n        bytes32 indexed batchId,\n        uint256 totalAmount,\n        uint256 normalisedBalance,\n        address indexed owner,\n        address indexed payer,\n        uint8 depth,\n        uint8 bucketDepth,\n        bool immutable_\n    );\n\n    event BatchMigrated(\n        bytes32 indexed batchId,\n        uint256 totalAmount,\n        uint256 normalisedBalance,\n        address indexed owner,\n        address indexed payer,\n        uint8 depth,\n        uint8 bucketDepth,\n        bool immutable_\n    );\n    event SwarmContractUpdated(address oldAddress, address newAddress);\n    event AdminTransferred(address oldAdmin, address newAdmin);\n\n    // Custom errors\n    error TransferFailed();\n    error ApprovalFailed();\n\n    // Modifiers\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Only admin can call this function\");\n        _;\n    }\n\n    constructor(address _swarmContractAddress) {\n        swarmStampContract = ISwarmContract(_swarmContractAddress);\n        admin = msg.sender;\n    }\n\n    ////////////////////////////////////////\n    //              SETTERS               //\n    ////////////////////////////////////////\n\n    /**\n     * @notice Transfer admin rights to a new address\n     * @param _newAdmin The address of the new admin\n     */\n    function transferAdmin(address _newAdmin) external onlyAdmin {\n        require(_newAdmin != address(0), \"New admin cannot be the zero address\");\n        address oldAdmin = admin;\n        admin = _newAdmin;\n        emit AdminTransferred(oldAdmin, _newAdmin);\n    }\n\n    /**\n     * @notice Updates the swarm contract address\n     * @param _newSwarmContractAddress New address of the swarm contract\n     */\n    function updateSwarmContract(\n        address _newSwarmContractAddress\n    ) external onlyAdmin {\n        address oldAddress = address(swarmStampContract);\n        swarmStampContract = ISwarmContract(_newSwarmContractAddress);\n        emit SwarmContractUpdated(oldAddress, _newSwarmContractAddress);\n    }\n\n    /**\n     * @notice Migrate batch data from old contract without performing token transfers\n     * @param _owner Address that owns the batch\n     * @param _batchId Batch ID from the old contract\n     * @param _totalAmount Total amount from the old batch\n     * @param _normalisedBalance Normalised balance from the old batch\n     * @param _nodeAddress Node address from the old batch\n     * @param _depth Depth from the old batch\n     * @param _bucketDepth Bucket depth from the old batch\n     * @param _immutable Immutable flag from the old batch\n     * @param _timestamp Original timestamp from the old batch\n     */\n    function migrateBatchRegistry(\n        address _owner,\n        bytes32 _batchId,\n        uint256 _totalAmount,\n        uint256 _normalisedBalance,\n        address _nodeAddress,\n        uint8 _depth,\n        uint8 _bucketDepth,\n        bool _immutable,\n        uint256 _timestamp\n    ) external onlyAdmin {\n        // Store the payer information\n        batchPayers[_batchId] = _owner;\n            \n        // Store batch information in the owner's batches array\n        ownerBatches[_owner].push(BatchInfo({\n            batchId: _batchId,\n            totalAmount: _totalAmount,\n            normalisedBalance: _normalisedBalance,\n            nodeAddress: _nodeAddress,\n            payer: _owner,\n            depth: _depth,\n            bucketDepth: _bucketDepth,\n            immutable_: _immutable,\n            timestamp: _timestamp\n        }));\n\n        // Emit the batch migration event\n        emit BatchMigrated(\n            _batchId,\n            _totalAmount,\n            _normalisedBalance,\n            _nodeAddress,\n            _owner,\n            _depth,\n            _bucketDepth,\n            _immutable\n        );\n    }\n\n    /**\n     * @notice Creates a new batch and registers the payer\n     * @param _owner Address that pays for the batch, but not the owner of the batch\n     * @param _nodeAddress Address of the node that will own the batch\n     * @param _initialBalancePerChunk Initial balance per chunk\n     * @param _depth Depth of the batch\n     * @param _bucketDepth Bucket depth\n     * @param _nonce Unique nonce for the batch\n     * @param _immutable Whether the batch is immutable\n     */\n    function createBatchRegistry(\n        address _owner,\n        address _nodeAddress,\n        uint256 _initialBalancePerChunk,\n        uint8 _depth,\n        uint8 _bucketDepth,\n        bytes32 _nonce,\n        bool _immutable\n    ) external {\n        // Calculate total amount\n        uint256 totalAmount = _initialBalancePerChunk * (1 << _depth);\n\n        // Transfer BZZ tokens from sender to this contract\n        if (!BZZ_TOKEN.transferFrom(msg.sender, address(this), totalAmount)) {\n            revert TransferFailed();\n        }\n\n        // Approve swarmStampContract to spend the BZZ tokens\n        if (!BZZ_TOKEN.approve(address(swarmStampContract), totalAmount)) {\n            revert ApprovalFailed();\n        }\n\n        // Call the original swarm contract with nodeAddress as owner\n        swarmStampContract.createBatch(\n            _nodeAddress,\n            _initialBalancePerChunk,\n            _depth,\n            _bucketDepth,\n            _nonce,\n            _immutable\n        );\n\n        // Calculate batchId as bytes32\n        bytes32 batchId = keccak256(abi.encode(address(this), _nonce));\n\n        // Store the payer information\n        batchPayers[batchId] = _owner;\n\n        // Get normalized balance\n        uint256 normalisedBalance = swarmStampContract\n            .currentTotalOutPayment() + _initialBalancePerChunk;\n            \n        // Store batch information in the owner's batches array\n        ownerBatches[_owner].push(BatchInfo({\n            batchId: batchId,\n            totalAmount: totalAmount,\n            normalisedBalance: normalisedBalance,\n            nodeAddress: _nodeAddress,\n            payer: _owner,\n            depth: _depth,\n            bucketDepth: _bucketDepth,\n            immutable_: _immutable,\n            timestamp: block.timestamp\n        }));\n\n        // Emit the batch creation event\n        emit BatchCreated(\n            batchId,\n            totalAmount,\n            normalisedBalance,\n            _nodeAddress,\n            _owner,\n            _depth,\n            _bucketDepth,\n            _immutable\n        );\n    }\n\n    ////////////////////////////////////////\n    //              GETTERS               //\n    ////////////////////////////////////////\n\n    /**\n     * @notice Get the payer address for a specific batch ID\n     * @param _batchId The ID of the batch\n     * @return The address of the payer\n     */\n    function getBatchPayer(bytes32 _batchId) external view returns (address) {\n        return batchPayers[_batchId];\n    }\n    \n    /**\n     * @notice Get all batches for a specific owner\n     * @param _owner The address of the owner\n     * @return Array of BatchInfo for the owner\n     */\n    function getOwnerBatches(address _owner) external view returns (BatchInfo[] memory) {\n        return ownerBatches[_owner];\n    }\n    \n    /**\n     * @notice Get the number of batches for a specific owner\n     * @param _owner The address of the owner\n     * @return The number of batches\n     */\n    function getOwnerBatchCount(address _owner) external view returns (uint256) {\n        return ownerBatches[_owner].length;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}